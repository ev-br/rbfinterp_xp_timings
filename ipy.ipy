# coding: utf-8
import os
import socket
import numpy as np

try:
   import torch
   HAVE_TORCH=True
except ImportError:
   HAVE_TORCH = False

try:
    import jax.numpy as jnp
    import jax
    HAVE_JAX = True
except ImportError:
   HAVE_JAX = False

from scipy.interpolate import RBFInterpolator
from scipy.stats.qmc import Halton


### what is the env ###
device = os.environ.get("SCIPY_DEVICE", "cpu")
jit = "jit" if os.environ.get("SCIPY_JIT", "0") == "1" else "nojit"
machine = socket.gethostname()

if HAVE_JAX:
    jax.config.update("jax_enable_x64", True)
    jax.config.update("jax_default_device", jax.devices(device)[0])


### Set up the interpolator ###

Nobs = 100
rng = np.random.default_rng(123)
xobs = 2*Halton(2, seed=rng).random(Nobs) - 1
yobs = np.sum(xobs, axis=1)*np.exp(-6*np.sum(xobs**2, axis=1))


### MANUAL: set the array library ###

xp = jnp # torch

xobs, yobs = map(xp.asarray, (xobs, yobs))
rbf = RBFInterpolator(xobs, yobs)

### checkpoint name ###
xp_name = rbf._xp.__name__
if 'compat' in xp_name:
    xp_name = xp_name.split('.')[-1]

fname = f"rbfinterp_time.{machine}.{xp_name}.{device}.{jit}.txt"

print(fname)
print(rbf._xp.__name__)
print(f"{device = }")
print(f"{jit = }")


### pre-compile ###
rbf(xp.asarray([[1, 1],  [2, 3]]))

result_list = []
with open(fname, 'w') as f:
    f.write("# N   time, s    stdev, s\n")


### Run the benchmark loop ###
for N1 in [50, 100, 500, 1000, 2000]:
    x1 = xp.linspace(-1, 1, N1)
    xgrid = xp.stack(xp.meshgrid(x1, x1, indexing='ij'))
    xflat = xgrid.reshape(2, -1).T     # make it a 2-D array

    print(N1, end=': ')
    res = get_ipython().run_line_magic('timeit', '-o yflat = jax.block_until_ready(rbf(xflat))')

    # checkpoint
    result_list.append([N1, res.average, res.stdev])
    with open(fname, "a") as f:
        f.write(", ".join(str(x) for x in result_list[-1]) + "\n")


